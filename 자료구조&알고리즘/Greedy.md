# **그리디 알고리즘**

그리디 알고리즘, 탐욕법이라고 불리는 이 알고리즘은 현재에서 최적이라고 생각하는 해를 선택하여 결론에 도달하는 방법이다.

항상 최적의 값이 아니라 최적의 값의 근사한 값을 목표로 하여 수행하는 것이 특징이다.

주로 문제를 분할 가능한 문제로 분할하고 각 문제들에 대한 최적해를 구한 뒤 이를 결합하여 전체 문제의 최적해를 찾는 방식

\[문제\] 노드에서 가장 합이 높은 방법을 선택하는 방법

![Alt text](image.png)

위 경우에서는 무작위로 선택하기 때문에 위 선택한 해는 최적해는 아니다.

그럼 현재 상황에서 최적의 해를 구하는 방법으로 한번 노드를 선택해보자

![Alt text](image-1.png)
이전 예시와 다르게  5에서 가장 최적인 10을, 10에서는 가장 최적인 4를 선택하였다.

> **◾ 근시안적 방법론**  
> 단기적인 목표를 중심으로 한 **전력적인 접근** 방법  
> 현재의 문제를 해결하는것에 초점, **단기적인 최고 성과**를 목표

> ◾ 근사 알고리즘  
> 최적의 해를 구할수는 없지만  근사한 해를 구하는 알고리즘을 의미, 근사 알고리즘은 항상 **최적해를 보장 X**  
> 많은 경우에서 **근사한 값**을 구할 수 있음

## **그리디 알고리즘 주요 속성**

두가지의 주요 속성이 만족해야 그리디 알고리즘으로 문제를 해결 가능

#### **1\. 탐욕 선택 속성**

각 **단계에서 최선의 선택**을 했을 때 전체 문제에 대한 **최적해**를 구할 수 있는 경우를 말합니다.

각 단계에서 가장 이상적인 선택을 하는 것이 전체적으로 최적의 결과를 가져온다.

#### **2\. 최적 부분 구조**

전체 문제의 최적해가 **부분문제의 최적해로 구성**될 수 있는 경우

즉 전체 문제를 작은 부분 문제로 나누어 각각의 부분 문제에서 최적의 해를 구한 후 이를 조합해서 전체 문제의 최적해를 구하는 것을 의미

**그리디 알고리즘 주요 속성**

## **그리디 알고리즘 단계**

그리디 알고리즘의 단계는 매 단계마다 최적의 선택을 하면서 최종적으로 전체적으로 최적 해답을 찾는 과정

> 1\. 문제의 최적해 구조를 결정  
> 2\. 문제의 구조에 맞게 선택 절차를 정의 **(선택 절차)**  
> 3\. 선택 절차에 따라 선택을 수행  
> 4\. 선택된 문제가 문제의 조건을 만족하는 지 검사 **(적절성 검사)**  
> 5\. 조건을 만족하지 않으면 해당 해를 제외  
> 6\. 모든 선택이 완료되면 해답 검사 **(해답검사)**  
> 7\. 조건 만족시 해답 인정 X

#### **1\. 선택 절차**

이 단계에서는 현재 상태에서 최적인 선택을 합니다.

해당 선택은 이후에 바뀌지 않음

#### **2\. 적절성 검사**

이 단계에서는 선택한 항목이 문제의 조건을 만족시키는지 확인

조건 불만족시 해당 항목은 제외

#### **3\. 해답 검사**

모든 선택이 완료되면 최종 선택이 문제의 조건을 만족하는지 확인

조건 만족시 해답 인정

## **예시 문제**

#### **◾ 거스름돈 문제**

**\[문제\]**

거스름돈으로 1260원을 걸러줘야 할 때 500,100,50,10원 짜리 동전으로만 줘야한다.

이때 가장 큰 동전을 많이 주는 방식으로 거스름돈을 주려고 한다.

**\[알고리즘 적용\]**

선택절차 : 거스름돈 문제에서 가장 가치가 큰 동전 부터 선택

적절성 검사 : 만약 선택된 동전의 가치가 거스름돈보다 크다면 다음으로 작은 동전을 선택

해답 검사 : 합이 일치하면 거스름돈 문제가 해결

```java
public ResponseEntity<ApiResponse<Object>> changeMoney() {

    Integer[] coins = {100, 10, 500, 50};   // 동전 종류
    int money = 1260;                       // 거스름돈
    int count = 0;                          // 동전 사용 개수

    Map<String, Object> resultMap = new HashMap<>();

    // 1. 선택 절차 적용 : 거스름돈 문제에서 가장 가치가 큰 동전부터 선택을 합니다.
    Arrays.sort(coins, Comparator.reverseOrder());

    // 2. 적절성 검사 : 만약 선택된 동전의 가치가 거스름돈보다 크다면 다음으로 작은 동전을 선택한다.
    for (int i = 0; i < coins.length; i++) {
        count += money / coins[i];
        money %= coins[i];
        resultMap.put(String.valueOf(coins[i]), count);
    }
    // 3. 해답 검사 : 합이 일치하면 거스름돈 문제가 해결되었습니다.
    if (money == 0) {
        System.out.println("거스름돈 문제가 해결되었습니다.");
    }

    // 결과값 : { "500" : 2, "100" : 4, "50" : 5, "10": 6 }

    ApiResponse<Object> ar = ApiResponse.builder()
            .result(resultMap)
            .resultCode(SUCCESS_CODE)
            .resultMsg(SUCCESS_MSG).build();
    return new ResponseEntity<>(ar, HttpStatus.OK);
}
```

#### **◾ 체육복 문제**

**\[문제\]**

점심시간에 도둑이 들어서 일부 학생이 체육복을 도난당했습니다. 다행히 여별 체육복이 있는 학생이 이들에게 체육복을 빌려주려고 한다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 빌려줄수 있다. 체육복이 없으면 수업을 못들어 최대한 많은 학생이 듣도록 체육복을 빌려줘야한다.

전체 학생수 n, 도난 학생 배열 lost, 여벌 체육복 학생 배열 reserve 일때 최대 체육복 받게 하는 학생수 리턴하는 솔루션

\[제약사항\]

전체 학생수 2-30명, 도난 학생 수는 1명 이상 n 명 이하, 여별 체육복을 가져온 학생수 1-n명 이며 중복되는 번호는 없음

\[그리디 알고리즘 적용\]

1\. 선택 절차 : 선택 과정에서 체육복을 읽어버린 학생과 여별 체육복을 가져온 학생의 번호를 오름차순으로 정렬

2\. 적절성 검사 : 체육복을 잃어버린 학생 중 여벌이 있는 학생에게 빌려줄 수 있는 학생 수 계산, 그 다음에는 체육복을 잃어버린 학생 중 여벌이 없는 학생에게 빌려줄 수 있는 학생 수 계산 

3\. 해답 검사 : 체육복을 빌려받은 학생 수 를 반환

```java
public ResponseEntity<ApiResponse<Object>> changeMoney(int n, int[] lost, int[] reserve) {
    int answer = n - lost.length; // 체육복이 없는 학생 수

    // 1. 선택 절차
    // 학생 번호를 기준으로 정렬합니다.
    Arrays.sort(lost);
    Arrays.sort(reserve);

    // 2. 적절성 검사
    // 체육복을 잃어버린 학생 중 여벌이 있는 학생에게 빌려줄 수 있는 경우
    for (int i = 0; i < lost.length; i++) {
        for (int j = 0; j < reserve.length; j++) {
            if (lost[i] == reserve[j]) { // 여벌 체육복을 가진 학생이 체육복을 잃어버린 경우
                answer++; // 체육복을 빌려받은 학생 수 증가
                reserve[j] = -1; // 빌려준 학생은 더 이상 빌려줄 수 없도록 표시
                break;
            }
        }
    }
    // 3. 해답 검사
    // 체육복을 잃어버린 학생 중 여벌이 없는 학생에게 빌려줄 수 있는 경우
    for (int i = 0; i < lost.length; i++) {
        for (int j = 0; j < reserve.length; j++) {
            if (reserve[j] == lost[i] - 1 || reserve[j] == lost[i] + 1) {
                answer++;
                reserve[j] = -1;
                break;
            }
        }
    }

    ApiResponse<Object> ar = ApiResponse.builder()
            .result(answer)
            .resultCode(SUCCESS_CODE)
            .resultMsg(SUCCESS_MSG).build();
    return new ResponseEntity<>(ar, HttpStatus.OK);
}
```

<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>