# **빈 스코프**

스프링 빈이 스프링 컨테이너가 생성되어서 종료될 때까지 유지되는 것으로 알고있다.

이것은 싱글톤 스코프로 생성되기 때문이다. 

싱글톤 : 기본 스코프, 컨테이너 시작부터 종료까지 유지 

프로토타입 : 스프링컨테이너는 프로토타입 빈의 생성과 의존관계 주입 까지만 관여하고 더 관리하지 않는 짧은 범위 스코프 (만들어서 던져주고 끝)

웹관련 스코프

\- request : 웹 요청이 들어오고 나갈때 까지 유지

\- session : 웹 세션이 생성되고 종료될 때 까지 유지

\- application :웹 서블릿 컨텍스와 같은 범위로 유지

\>스프링 웹과 관련된 기능이 들어와야 사용 가능 

@Scope("") 어노테이션을 통해서 스코프를 지정 가능하다.

<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>

## **1\. 프로토타입 스코프**

프로토타입 스코프를 스프링 컨테이너에 조회하면 항상 새로운 인스턴스를 생성해서 반환해준다.

[##_Image|kage@qscPG/btsESpHiaWQ/q7scGt8wzB8HDOT7gEB2T0/img.png|CDM|1.3|{"originWidth":1015,"originHeight":533,"style":"alignCenter","width":721,"height":379}_##]

그림처럼 기존의 싱글톤 형태가 아니기 때문에 요청이 들어옴에 따라 새로운 프로토타입 빈을 계속 생성한다.

그리고 이 빈을 클라이언트에 전달하고 관리를 하지 않는다.

1\. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청

2\. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성, 의존 주입

3\. 스프링 컨테이너는 생성한 프로토타입 빈을 반환

4\. 이후 같은 요청이 오면 또 새로운 프로토타입 빈을 생성 후 반환

> 핵심은 스프링 컨테이너는 프로토타입 빈을 생성, 의존주입, 초기화 까지만 처리해서 전달  
> 클라이언트에 반환된 빈을 더 관리하지 않고, 그 관리는 클라이언트에서 해야한다.  
> @PreDestory를 통한 종료 콜백이 없다.

## **2\. 문제점**

단순하게 프로토타입 빈의 스코프를 알고 활용하는 것은 어렵지 않다.

하지만 현업에서는 싱글톤 빈과 함께 사용하는 일이 종종 발생하며 이때 의도대로 동작하지 않을 수 있다.

이 문제점이 무엇인지 한번 알아보자

[##_Image|kage@ORrlb/btsES2kNn5P/gUyANuNy2CHOTWEZSTKQJ0/img.png|CDM|1.3|{"originWidth":1013,"originHeight":541,"style":"alignCenter","width":766,"height":409}_##]

스프링 컨테이너에 프로토타입 빈을 요청한다.

[##_Image|kage@Np8zR/btsES86m23Z/x4mRkYHTw5xCWE8Z4N4Kf1/img.png|CDM|1.3|{"originWidth":1012,"originHeight":508,"style":"alignCenter","width":764,"height":384}_##]

위 그림의 상황을 먼저 이해해보자

클라이언트 빈이라는 싱글톤 빈은 의존관계로 프로토타입빈을 주입받아야하는 상태이다.

클라이언트 빈을 생성하고 의존 주입을 위해 프로토타입 빈을 요청하고 생성 후 반환 받은 상태

[##_Image|kage@ejiqB4/btsEXqqJhwQ/CRVa93RxceKAhRYct08ck1/img.png|CDM|1.3|{"originWidth":1437,"originHeight":676,"style":"alignCenter","width":796,"height":374}_##]

이제 다음 상황을 보자

클라이언트 A가 로직을 호출한다.

로직은 클라이언트빈은 프로토타입빈의 addCount() 메서드를 호출하고 프로토타입 빈의 현재 count를 반환하는 로직이다.

[##_Image|kage@Jba12/btsETYoFj1c/5CKGbhodZsV946OHMGuC41/img.png|CDM|1.3|{"originWidth":1443,"originHeight":669,"style":"alignCenter","width":741,"height":344}_##]

다음 상황으론느 클라이언트 B가 동일하게 로직을 동작시켰다. 

이때 clientBean은 싱글톤이고 이미 의존관계로 프로토타입@x01을 참조하여 사용하는 중이라 카운트는 1->2로 증가

\> 프로토타입 빈은 호출 시 새로 생성해서 반환하는게 맞지만 여기서는 이미 의존관계로 주입된 상태를 사용하는 것이며 addCount라는 메서드를 호출하기 때문에 새로 생성되니ㅡㄴ게 아님

프로토타입 빈을 사용하는 이유는 호출 시점 마다 새로운 빈을 사용하고 싶어서 쓰는 경우가 대부분

그렇기 때문에 의도된 프로토타입 빈 사용이 아닌 것이다.

참고

여러 빈에서 같은 프로토타입 빈을 주입받으면 주입받는 시점에서 새로운 프로토타입 빈이 생성

A,B 두명의 클라이언트가 있을때 각각 의존관계를 주입받으면 서로 다른 인스턴스의 프로토타입 빈을 주입

하지만 사용시점 마다 새로 생성되는 건 아니다.

> 아마 영한님이 배민 출신 개발자이고 배민 서비스에서 가장 이런 프로토타입 빈을 사용하는 상황은 장바구니가 아닐까 생각된다.  
> 장바구니 기능이 다른 가게의 물품을 담을때 초기화 되는데 이게 마치 클라이언트 빈에서 로직을 호출하다가 다른 가게 제품을 담는 순간 새로운 프로토타입 빈을 호출해서 새롭게 다시 담는 형태가 비슷해 보인다.  
>   
> 스프링 공부를 하면서 가장 막연한 순간은 이론은 실무 즉 비지니스 로직을 개발할 때 어떻게 쓰일까를 모를때 일어난다고 생각한다. 그렇기 떄문에 강의 마다 자신이 생각하는 비지니스 개발을 상상하며 적용해보면 좋을 것 같다.

## **3\. Provider 사용**

## **1\. 프로토타입 스코프**

<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>