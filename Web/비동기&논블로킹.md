
# **비동기 / Non-Blocking** 

최근 사내에서 Fast API를 사용해서 추론 API를 개발해야하는 프로젝트를 수행했고 앞으로 node.js를 쓸지도 Webflux를 사용해야하는 상황에서도 비동기, 동기에 대한 개념을 확실히 집고 넘어가야한다.

## **동기 / 비동기**

영어로 하면 Synchronous / Asynchronous 이다.즉 동시에 실행한다 아니다 로 해석할 수 있다.

작업을 맞춰 실행한다라는 것 요청한 작업이 완료 여부를 따지고 순차대로 처리하는 것이다.

**Asynchronous**는 요청한 작업에 대한 **완료 여부를 따지지 않겠다** 라는 의미이다.

위 그림을 통해서 보면 동기 작업은 B 프로세스가 완료해야 A 프로세스를 실행하는 상황이지만 비동기 작업은 기다리지 않는 다는게 점

#### **◾** **비동기 장점**

비동기를 쓰는 건 결국 성능을 향상시키기 위함이다.

요청한 작업의 완료를 기다리지 않고 자신의 다음 과정을 수행하는 것은 만약 요청 작업이 I/O 작업과 같은 느린 작업이 발생 할때 기다리지 않고 다른 작업을 하는 멀티 플레이를 할 수 있기 떄문

성능적으로 4개의 작업을 최대는 28초에서 10초 까지 줄일 수 있는 장점이 있다.

데이터베이스 쿼리 수행 작업 이 있다고 할때 동기작업으로 처리하면 데이터베이스 응답이 올때 까지 기다려야한다.

그러면 웹 어플리케이션은 다른 작업을 처리하지 못한다. 이게 대용량 트래픽 상황이면 단체 성능 저하가 온다

동기식으로 수행하면 아래 노진구 처럼 되는거다

여기서 동시에 처리하는 건데 이 개념은 두 개 이상의 작업이 동시에 처리되는건데 이는 멀티 쓰레드, 멀티 프로세싱 방식으로 구현한다. JS는 비동기로 작업 요청하면 내장된 멀티쓰레드로 이루어진 Web API에 작업이 인가되어서 Call Stack과 동시에 처리된다.

백그라운드에 작업을 양도하는 개념으로 생각하면 된다.

#### **◾** **비동기 처리의 순서**

동기와 비동기는 요청 작업의 완료 여부에 대한 차이다. 즉 여러개의 작업을 순차처리하냐 아니냐의 차이이다.

동기는 순서가 지켜지고 비동기는 순서가 안지켜진다. 어떤 시점에 작업을 요청했던게 완료가 되는게 아니다.

## **Blocking / Non-Blocking'**

Blocking 과 Non Blocking은 현재 작업을 차단하냐 안하냐의 차이다.

이게 참 애매한게 동기/비동기랑 개념적으로 너무 비슷해 보이는데 개념적인 차이가 있다.

블로킹/논블로킹은 전체적인 작업 흐름을 막냐 안막냐의 개념이다.

파일 읽는 작업이 있으면 블로킹은 파일 읽기 완료전까지 다른 작업을 막고 논블로킹은 막지 않는것이다.

#### **◾ 비동기 vs Non-Blocking**

비동기와 논블로킹은 진짜 비슷한 개념으로 보인다. 아니 말만 다르지 똑같은거 아닌가 라고 생각할 수 있다

JS의 setTimeout 함수는 논블로킹이면서 비동기 함수인데 이는 어떤 관점으로 보느냐에 따라서 달라진다.

```
console.log("시작");

setTimeout(() => {
  console.log("1초 후에 실행됩니다!");
}, 1000);

console.log("끝");
```

이런 코드가 있을떄 출력은 시작 끝 1초후에 실행됩니다 순서로 실행된다.

즉 타이머작업 완료를 기다리지 않고 다른 작업을 수행하는 것이다.

타이머 완료 작업의 알람은 콜백 함수를 통해서 값을 받아서 출력하였다. 따라서 setTimeout은 현재 비동기의 관점

다른 시각으로 보면 타이머 작업을 수행하기 위한 메인 함수를 블락하는게 아니라 백그라운드에서 별도로 처리한다.

즉 이 경우에는 Non-Blocking을 하는 것이다.

👉 비동기나 논블로킹이나 추구하는 방향성을 동일하다. 시점과 관련된 이론적인 개념부분이라 이걸 실제 코드에서 경계를 구분하기가 참 어렵다. 다만 이게 엄연히 다른 발상이라는 것을 기억하자!!
